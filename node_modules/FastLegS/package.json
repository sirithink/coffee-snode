{
  "name": "FastLegS",
  "version": "0.3.3",
  "description": "PostgreSQL ORM on top of node-postgres",
  "tags": [
    "orm",
    "pg",
    "postgres",
    "mysql"
  ],
  "author": {
    "name": "Didit Tech",
    "email": "development@didit.com"
  },
  "homepage": "https://github.com/didit-tech/FastLegS",
  "dependencies": {
    "async": "0.1.18",
    "pg": "0.8.1",
    "mysql": "2.0.0-alpha3",
    "underscore": "1.4.3",
    "underscore.string": "2.3.1"
  },
  "devDependencies": {
    "mocha": "1.7.4",
    "expect.js": "0.1.2",
    "read": "0.1.0"
  },
  "main": "index",
  "scripts": {
    "test": "make test-unit"
  },
  "engines": {
    "node": ">= 0.8.18 <= 0.9.0"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/didit-tech/FastLegS/raw/master/LICENSE"
    }
  ],
  "readme": "[![Build Status](https://secure.travis-ci.org/didit-tech/FastLegS.png)](http://travis-ci.org/didit-tech/FastLegS)\n#FastLegS\n\nPostgreSQL ORM on top of node-postgres.\n\n##Installation\n\n    npm install FastLegS\n\n##Quickstart\n\n**NOTE:** As of version```0.2.0```, both PostgreSQL and MySQL are supported. \nYou indicate which database you are using at object instantiation time. All \nother operations and interfaces behave the same as older versions.\n\n### Setup for versions < ```0.2.0```\n\n    var FastLegS = require('FastLegS');\n    ...\n    FastLegS.connect(connectionParams);\n    ...\n\n### Setup for versions >= ```0.2.0```\n\n### MySQL:\n\n    var FastLegSBase = require('FastLegS');\n    var FastLegS = new FastLegSBase('mysql');\n    ...\n    FastLegS.connect(connectionParams);\n    ...\n\n### PostgreSQL:\n\n    var FastLegSBase = require('FastLegS');\n    var FastLegS = new FastLegSBase('pg');\n    ...\n    FastLegS.connect(connectionParams);\n    ...\n\n### Example:\n\n    var FastLegSBase = require('FastLegS');\n\n    // gonna use PostgreSQL\n    var FastLegS = new FastLegSBase('pg');\n\n    var connectionParams = {\n      user: 'shes'\n    , password: 'got'\n    , database: 'legs'\n    , host: 'localhost'\n    , port: 5432\n    }\n\n    FastLegS.connect(connectionParams);\n\n    var Post = FastLegS.Base.extend({\n      tableName: 'posts',\n      primaryKey: 'id'\n    });\n\n    Post.create(\n      { title: 'Some Title 1', body: 'Some body 1' }, \n      function(err, results) {\n        Post.find(\n          { 'title.ilike': '%title%' }, \n          { only: ['id', 'body'] }, \n          function(err, post) {\n            // Hooray!\n          }\n        );\n      }\n    );\n\n#The Full Monty\n\nThe following examples use these database tables as examples:\n\n### posts\n\n| id   | title        | blurb        | body        | published   |\n|------|--------------|--------------|-------------|-------------|\n| 1    | Some Title 1 | Some blurb 1 | Some body 1 | false       |\n| 2    | Some Title 1 | Some blurb 2 | Some body 2 | true        |\n| 3    | Some Title 1 | Some blurb 3 | Some body 3 | false       |\n| 4    | Some Title 1 | Some blurb 4 | Some body 4 | true        |\n\n### comments\n\n| id | post_id | comment   | created_at |\n|----|---------|-----------|------------|\n|  1 |       1 | Comment 1 | 2012-12-11 |\n|  2 |       1 | Comment 2 | 2012-12-11 |\n|  3 |       2 | Comment 3 | 2012-12-11 |\n|  4 |       2 | Comment 4 | 2012-12-11 |\n|  5 |       3 | Comment 5 | 2012-12-11 |\n|  6 |       3 | Comment 6 | 2012-12-11 |\n|  7 |       4 | Comment 7 | 2012-12-11 |\n|  8 |       4 | Comment 8 | 2012-12-11 |\n\nGiven this setup:\n\n    var FastLegSBase = require('FastLegS');\n\n    // gonna use PostgreSQL\n    var FastLegS = new FastLegSBase('pg');\n\n    var connectionParams = {\n      user: 'shes', password: 'got',\n      database: 'legs', host: 'localhost', port: 5432\n    }\n\n    FastLegS.connect(connectionParams);\n\n    var callback = function(err, results) {\n      console.dir(err);\n      console.dir(results);\n    }\n    \n    var Comment = FastLegS.Base.extend({\n      tableName: 'comments',\n      primaryKey: 'id'\n    });\n    \n    var Post = FastLegS.Base.extend({\n      tableName: 'posts',\n      primaryKey: 'id'\n    });\n\nThe following are examples of basic CRUD operations:\n\n##Create\n\nCalls to ```create``` can take an object or an array of objects.\n\n    Post.create(\n      { id: 5, title: 'Some Title 5', body: 'Some body 5' },\n      callback\n    )\n\n    Post.create(\n      [{ id: 6, title: 'Some Title 6', body: 'Some body 6' },\n       { id: 7, title: 'Some Title 7', body: 'Some body 7' }],\n      callback\n    )\n\nThe ```results``` passed to the callback are different depending on the \ndatabase.\n\nIn the case of PostgreSQL, the ```results``` will be an object of the form:\n\n    {\n      rows: [{ id: 5,\n             title: 'Some Title 5',\n             blurb: null,\n             body: 'Some body 5',\n             published: null }],\n      command: INSERT,\n      rowCount: 1,\n      oid: 0\n    }\n\nIn the case of MySQL, the ```results``` will be an object of the form:\n\n    {\n      fieldCount: 0,\n      affectedRows: 1,\n      insertId: 0,\n      serverStatus: 2,\n      warningCount: 0,\n      message: ''\n    }\n\n##Read\n\nThe various forms of the ```find``` command are very flexible. We'll present a \nfew of them here.\n\n####All:\n\n    Post.find({}, callback)\n\noutputs:\n\n    [ \n      { id: 1,\n        title: 'Some Title 1',\n        blurb: null,\n        body: 'Some body 1',\n        published: null,\n        created_at: null,\n        updated_at: null },\n      ...\n      { id: 5,\n        title: 'Some Title 5',\n        blurb: null,\n        body: 'Some body 5',\n        published: null,\n        created_at: null,\n        updated_at: null },\n      { id: 6,\n        title: 'Some Title 6',\n        blurb: null,\n        body: 'Some body 6',\n        published: null,\n        created_at: null,\n        updated_at: null },\n      { id: 7,\n        title: 'Some Title 7',\n        blurb: null,\n        body: 'Some body 7',\n        published: null,\n        created_at: null,\n        updated_at: null } \n    ]\n\n####By primary key:\n\n    Post.find(6, callback)\n\noutputs:\n\n    {\n      id: 6,\n      title: 'Some Title 6',\n      blurb: null,\n      body: 'Some body 6',\n      published: null,\n      created_at: null,\n      updated_at: null\n    }\n\n####Only show some fields:\n\n    Post.find(6, {only: ['id','title']}, callback)\n\noutputs:\n\n    { id: 6, title: 'Some Title 6' }\n\n####Some clauses:\n\n    Post.find({'title.like': 'Some%'}, callback)\n    Post.find({'id.in': [6, 7]}, callback)\n    Post.find({'id.nin': [6]}, callback)\n    Post.find({'$or': {'id.equals': 5, 'body.like': '%body 7'}}, callback)\n\n####Order, offset, limit\n\n    Post.find({}, { order: ['-id'] }, callback)\n    Post.find({}, { offset: 1, limit: 1 }, callback)\n\n####Count:\n\n    Post.find({}, {count: true}, callback)\n\noutputs:\n\n    { count: 7 }\n\n##Update\n\n    Post.update(\n      { title: 'Some Title 6' },\n      { title: 'Renamed title' },\n      callback\n    )\n\n##Delete\n\n    Post.destroy({ 'id.in': [5, 7]}, callback)\n    Post.truncate(callback)\n\n##A Taste of Relationships\n\nYou can call out relationships when you extend FastLegS.Base:\n\n    var Post = FastLegS.Base.extend({\n      tableName: 'posts',\n      primaryKey: 'id',\n      many: [\n        { 'comments': Comment, joinOn: 'post_id' }\n      ]\n    });\n    \nYou can then create complex object relationships with join logic:\n\n    Post.find(\n      {}, \n      { include: { comments: { only: ['id', 'comment'] } } },\n      callback\n    )\n\noutputs:\n\n    [\n      {\n          body: 'Some body 1',\n          title: 'Some Title 1',\n          id: 1,\n          updated_at: null,\n          published: false,\n          blurb: 'Some blurb 1',\n          created_at: null,\n          comments: [\n              { id: 1, comment: 'Comment 1' },\n              { id: 2, comment: 'Comment 2' }\n          ]\n      },\n      {\n          body: 'Some body 2',\n          title: 'Some Title 2',\n          id: 2,\n          updated_at: null,\n          published: true,\n          blurb: null,\n          created_at: null,\n          comments: [\n              { id: 3, comment: 'Comment 3' },\n              { id: 4, comment: 'Comment 4' }\n          ]\n      },\n      ...\n    ]\n\nHere's a many-to-many example based on these tables:\n\n### students\n\n| id | name      |\n|----|-----------|\n| 1  | Abe       |\n| 2  | Ben       |\n| 3  | Christine |\n| 4  | Delia     |\n| 5  | Egwene    |\n\n### professors\n\n| id | name   |\n|----|--------|\n| 6  | Felix  |\n| 7  | Garret |\n| 8  | Horton |\n| 9  | Irene  |\n| 10 | Jane   |\n\n### student_professor\n\n| student_id | professor_id |\n|------------|--------------|\n| 1          | 6            |\n| 2          | 6            |\n| 3          | 7            |\n| 4          | 7            |\n| 5          | 8            |\n| 1          | 8            |\n| 2          | 9            |\n| 3          | 9            |\n| 4          | 10           |\n| 5          | 10           |\n\n\n    var Student = FastLegS.Base.extend({\n      tableName: 'students',\n      primaryKey: 'id',\n    });\n\n    var Professor = FastLegS.Base.extend({\n      tableName: 'professors',\n      primaryKey: 'id',\n    })\n\n    var StudentProfessor = FastLegS.Base.extend({\n      tableName: 'student_professor',\n      foreignKeys: [\n         { model: Student, key: 'student_id' },\n         { model: Professor, key: 'professor_id' }\n      ]\n    })\n\n    Student.many = [{\n      professors: Professor,\n      assoc: StudentProfessor\n    }]\n\n    Professor.many = [{\n      students: Student,\n      assoc: StudentProfessor\n    }]\n\n    Professor.findOne(\n      9,\n      {include: { students: {} }},\n      function(err, result) {\n        inspect(result)\n      }\n    )\n\noutputs:\n\n    {\n      id: 9,\n      name: 'Irene',\n      students: [\n          { id: 2, name: 'Ben' },\n          { id: 3, name: 'Christine' }\n      ]\n    }\n\nThis shows that ```professor``` Irene has ```students``` Ben and Christine\n\n##Summary\n\nThe tests are an excellent reference for the various modifiers and syntactic \nsugar you can use in FastLegS.\n\n##ToDo\n\nRight now, the codebase is split because of syntactic differences between \nPostgreSQL and MySQL. There is a lot of duplicated code, however. Future \nversions should abstract out the differences and merge the duplicated code.\n\nWatch for updates to examples in the near future to show features like \nrelationships and advanced queries.\n\n#Contributors\n\n* Micah Silverman ([dogeared](https://github.com/dogeared))\n* Thad Clay ([thadclay](https://github.com/thadclay))\n* Jan Paul Erkelens ([jperkelens](https://github.com/jperkelens))\n* Rob Malko ([malkomalko](https://github.com/malkomalko))\n* Jim Drannbauer ([excellentdrums](https://github.com/excellentdrums))\n",
  "readmeFilename": "README.md",
  "_id": "FastLegS@0.3.3",
  "dist": {
    "shasum": "dc49d4763aa44937e3c47eb6f985c1e4f832f259"
  },
  "_from": "FastLegS@0.3.3"
}
